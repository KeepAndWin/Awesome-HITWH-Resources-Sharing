<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>第四单元 线程</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="5d1bc881-8e3d-4fde-acb7-72ffcbe44843" class="page sans"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/gradients_3.png" style="object-position:center 60%"/><div class="page-header-icon page-header-icon-with-cover"><span class="icon">📌</span></div><h1 class="page-title">第四单元 线程</h1></header><div class="page-body"><p id="197291a0-ef54-4340-82e4-e3b6b0a80f96" class="block-color-gray">Thread</p><h1 id="3d134327-4846-4501-8314-83a9e8b54b8e" class="">4.1 线程概述</h1><hr id="c39bfea7-b357-4c6a-aaf7-32b06a5038b4"/><h2 id="22ad026c-e330-4679-8652-204ac6171f41" class="">一、概述</h2><ul id="06a2b1cb-55eb-4f40-9337-e3f22097f724" class="toggle"><li><details open=""><summary>引入：</summary><ol id="45cf9aeb-0189-4d9d-aed8-5478ce45fa96" class="numbered-list" start="1"><li>进程有两个基本的属性，从而能够成为可以并发执行的<strong>基本单位</strong><ul id="20b7a6c1-924b-4773-bf2a-38ec3d88bcf3" class="bulleted-list"><li>是一个<mark class="highlight-red">拥有资源</mark>的独立单位，可以独立的分配虚地址空间和其他资源</li></ul><ul id="2fb23902-ad86-424d-89da-48d55e9bfc88" class="bulleted-list"><li>是一个可以<mark class="highlight-red">独立调度</mark>和<mark class="highlight-red">分派</mark>的基本单位</li></ul></li></ol><ol id="3a623ff3-5aae-473f-9360-1602e10bbc7d" class="numbered-list" start="2"><li>矛盾点——进程：高并发vs高时空开销<ul id="4526ed07-ea55-4e34-920a-812264249e84" class="bulleted-list"><li>由于进程作为一个资源的拥有者，在进程的创建、撤销和切换的时候的时空开销比较大，因此需要进程的数目不能过多，而且切换频率不能太大</li></ul><ul id="1738812a-61c3-4f57-8f62-d947fbed63f5" class="bulleted-list"><li>为了提高资源的利用率，OS必须能高并发执行任务，因此提高进程数是有必要的</li></ul><figure id="6d26261f-9afc-400c-a19b-0f4cb82309e7" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled.png"><img style="width:480px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled.png"/></a></figure></li></ol><ol id="efc95f3c-89db-4724-86c6-053f2b652db7" class="numbered-list" start="3"><li>解决方案：分离进程的两个基本属性<ul id="5bd9ce98-f983-4c61-9eb8-85c7e5070e8b" class="bulleted-list"><li>作为<mark class="highlight-red">资源</mark>的拥有单位时，不需要对其作频繁的切换工作</li></ul><ul id="a9a06df3-937b-4859-9736-9cb0cfcdd7dd" class="bulleted-list"><li>作为<mark class="highlight-red">调度</mark>的基本单位时，不给予拥有资源的单位，轻装上阵，引入线程的概念来用小开销提高进程内的并发程度</li></ul></li></ol></details></li></ul><ul id="500b19cd-3516-49e1-a7e1-1220dcbd76c1" class="toggle"><li><details open=""><summary>线程的定义：</summary><ul id="4bc88a58-754b-4ee2-b0ed-99b95e9a7d0f" class="bulleted-list"><li>大部分现代应用软件是多线程，线程是运行在应用进程里的，比进程更小的<mark class="highlight-red">运行单位</mark></li></ul><ul id="486691ad-b742-4c0c-8048-4a5e79efabc8" class="bulleted-list"><li><strong>线程</strong>作为<strong>CPU调度</strong>的基本单位，而<strong>进程</strong>作为<strong>资源分配</strong>的基本单位</li></ul><ul id="566fbfcd-3af9-4314-897c-9b69e1dd2851" class="bulleted-list"><li>一个应用程序大部分由各种<strong>进程</strong>来组成</li></ul><figure id="c6c33f15-5280-4e1a-9710-92f3022b0b0d" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%201.png"><img style="width:576px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%201.png"/></a></figure></details></li></ul><ul id="53bc4617-340a-4045-871d-c805188c4097" class="toggle"><li><details open=""><summary>线程的特点：</summary><ul id="034a69f5-08d3-4d5c-b24a-bd5b40a5b967" class="bulleted-list"><li>线程的运行是进程内部的执行轨迹，是进程内部执行指令的跟踪</li></ul><ul id="469d96e3-8581-4a23-8184-4a7f975e5db9" class="bulleted-list"><li>OS将资源以进程为单位分配，同一个进程下的<strong>所有线程共享进程拥有的所有资源</strong></li></ul><ul id="1a936a5d-ceac-46c8-864d-59447eafd9ff" class="bulleted-list"><li>线程拥有<strong>就绪</strong>、<strong>阻塞</strong>和<strong>执行</strong>三种基本状态</li></ul><ul id="b5fc1679-9c4f-4610-86b1-5f3120c770db" class="bulleted-list"><li>线程是<strong>独立的调度对象</strong>，不同的线程之间可以<strong>并发执行</strong></li></ul><ul id="cec43848-2f8f-4950-bcf8-731281b45c97" class="bulleted-list"><li>拥有部分必不可少的资源：线程状态、程序计数器PC、寄存器上下文和栈</li></ul><ul id="380d66d9-4083-4710-8584-907fe2f7d8bd" class="bulleted-list"><li>一个线程与其对等的线程共享3：<ul id="e39d0a0b-1003-48e8-86f1-c4553e6a0ced" class="bulleted-list"><li>代码段、全局变量</li></ul><ul id="2f447fa1-eb82-45ef-8d0d-55d66d325e72" class="bulleted-list"><li>打开的文件表示符</li></ul><ul id="15693715-dbda-463d-8e3d-0968856b5037" class="bulleted-list"><li>工作环境，包括当前目录、用户权限等</li></ul></li></ul><p id="53224f24-738e-4bac-ab6e-6e1f27cec4f5" class="">例：<strong>网页浏览软件：</strong></p><ul id="6a69d26a-27f1-40e3-be27-707805fedb5d" class="bulleted-list"><li>客户端：一个浏览器软件由显示内容、处理拼写检查、网络处理等多个进程来组成</li></ul><ul id="ee111f21-c131-443f-a258-3ae8d29f11b1" class="bulleted-list"><li>网页服务器程序：由监听用户请求（每个用户请求都不一样）、负责处理用户请求的进程来组成</li></ul></details></li></ul><ul id="748778b5-c0f0-4edf-8650-c2aba5862382" class="toggle"><li><details open=""><summary>线程的优点（相比于只用进程）：</summary><ul id="102bb027-6f45-4b2b-b313-6e8deb6d52e5" class="bulleted-list"><li>线程的创建时间、终止时间、资源回收和上下文切换都会短于进程</li></ul><ul id="5e291572-fa7b-4803-8d00-90b87331ba0c" class="bulleted-list"><li>由于同级线程之间<strong>共享内存和文件资源等</strong>，因此可以<strong>不通过内核</strong>（直接读写数据段、全局变量）进行直接通讯</li></ul><ul id="daa6a84e-8eac-4859-a7bc-72574d68eb54" class="bulleted-list"><li>引入线程后<strong>并发能力</strong>提升，不仅<mark class="highlight-red">进程之间可以并发执行，进程内部的</mark><mark class="highlight-red"><strong>线程也可以并发执行</strong></mark></li></ul></details></li></ul><ul id="799dfd22-6395-4458-9ab4-bbc08a4448a5" class="toggle"><li><details open=""><summary>多线程的优点</summary><p id="53a1673e-7aeb-4e6b-a6fb-bd9b1129703e" class="">线程的运行是进程内部的执行轨迹，是进程内部执行指令的跟踪（运行的东西都在线程里）</p><ul id="3c74ef02-a96a-4d56-a222-51d635b13420" class="bulleted-list"><li>响应时间快：
在多线程的应用执行中，即使部分线程发生阻塞，其他线程可以继续运行，提高了响应速度</li></ul><ul id="1f7adb3d-0a4b-41f5-bd99-0796f4b033fd" class="bulleted-list"><li>资源共享：
共享所属进程的内存和资源</li></ul><ul id="49f65528-9c4a-4802-b6e1-79096a0cd711" class="bulleted-list"><li>经济：
创建和切换线程更加经济</li></ul><ul id="f076010b-72d6-4445-9db8-9283e7b6f244" class="bulleted-list"><li>多处理器体系结构的利用：
多线程可以在多处理器上<strong>并行</strong>运行<blockquote id="9b52b51a-715a-4510-a457-aba8c46c2f9f" class="">并行：若干事件<mark class="highlight-red">同一时刻</mark>发生
并发：若干事件<mark class="highlight-red">同一时间间隔内</mark>发生</blockquote><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="49ff22b4-76b8-44eb-ab7c-f33b86b3a0e5"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">1. 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。
2. 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。
3. 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。

<mark class="highlight-red">并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。</mark></div></figure><figure id="0f5819f5-b6b7-44aa-a7b5-11a6332b9eb9" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%202.png"><img style="width:526px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%202.png"/></a></figure><blockquote id="f280c7b0-7219-4409-8ea4-79c822c12f86" class="">线程之间不能共享的是<mark class="highlight-red">栈、寄存器、程序计数器</mark></blockquote></li></ul></details></li></ul><ul id="da808206-8d3c-46d6-8595-d280125eb1be" class="toggle"><li><details open=""><summary>多线程服务器的实现结构：</summary><p id="70417550-afce-4695-bcbc-5d9abc62d857" class="">服务器在接收到客户端的请求之后，不是创建新的进程去响应请求，而是创建了一个被称为“工作线程”的新的线程去响应请求，这样的开销比创建一个新的进程要小。我们会创建一些线程放在“线程池”中，当接收到请求时，能够迅速分配给它一个线程响应客户端的请求</p><figure id="bf55c0f3-7abb-4c87-9100-02955c6912f7" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%203.png"><img style="width:509px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%203.png"/></a></figure></details></li></ul><p id="8058108f-f28e-4027-b76e-b1e374609e5f" class="">
</p><h2 id="94207df5-5f94-4d7e-8e55-07b4a546668c" class="">二、多线程模型</h2><ul id="de491e66-2e96-4c8c-9ca0-ec6e25ab21a9" class="toggle"><li><details open=""><summary>用户线程和内核线程</summary><ol id="eedaf482-3e13-441d-8ff9-128fd7e91abd" class="numbered-list" start="1"><li>用户线程：1<p id="5ee9ad22-52ed-4642-8b99-411b1e9c981a" class=""><mark class="highlight-red">用户线程受到内核的支持，用户线程是由用户层的线程库来管理，无需内核管理</mark></p><ul id="0b54dfe5-85d0-4739-8a9a-3658e16817e6" class="bulleted-list"><li>受OS的支持但不依赖于OS核心，应用程序的进程<strong>通过线程库提供创建、同步、调度和管理线程的函数来控制用户线程</strong>，这种调度通常在应用软件内部完成，不需要用户态和核心态的切换，<strong>速度很快</strong></li></ul><ul id="cd0cb370-91c4-469f-b982-c43737620e9f" class="bulleted-list"><li><mark class="highlight-blue_background">内核不了解用户线程的存在，是对用户线程无感知的，因此用户线程之间的切换也不需要内核特权，而且也不能作为内核调用的基本单位，用户线程的调用单位是其父进程</mark></li></ul><ul id="4b4a7fae-6561-48ab-91e6-5a10bb59dc4a" class="bulleted-list"><li>用户线程是在用户空间进程的创建和运行，在用到操作系统的一些功能的时候，必须要映射到内核空间，因此用户线程和内核线程之间必然会存在一种关系（一对一、多对一、一对多、多对多）</li></ul></li></ol><ol id="8ffb06ce-7b62-47f3-bc64-4551f3a81893" class="numbered-list" start="2"><li>内核线程：2<ul id="bd2238e6-8e5c-4ac3-beee-814c364ed2da" class="block-color-red bulleted-list"><li>类似于进程，内核来管理</li></ul><ul id="f58166ef-06f5-4b23-b2a4-00afa59d10fe" class="block-color-red bulleted-list"><li>由内核维护内核线程和其父进程的上下午信息，内核线程的切换也是由内核完成</li></ul><ul id="4d7afee6-6034-44f1-99b8-a73722cc255f" class="bulleted-list"><li>是内核调用的基本单位，时间片直接分配给内核线程。因此多内核线程的进程能够获得更多的CPU时间。</li></ul></li></ol></details></li></ul><ul id="6aa7604a-d605-49d4-b229-ec1cb7c090cb" class="toggle"><li><details open=""><summary>模型假设</summary><ul id="51e0c20e-3c7c-4181-9f28-f6d66a582ec3" class="bulleted-list"><li>我们做出如下假设<ul id="2ea61e62-9279-4bd0-8046-01cf456ff81d" class="bulleted-list"><li>操作系统支持内核线程</li></ul><ul id="7fe6fef0-b9b1-4f46-aed5-1795498f6f24" class="bulleted-list"><li>内核线程看作一个<mark class="highlight-red">进程</mark></li></ul><ul id="9ac4ab94-b090-4aa9-a390-e6bd5767709f" class="bulleted-list"><li><strong>用户线程基于内核线程运行</strong>，即用户线程阻塞内核线程阻塞、内核线程阻塞用户线程也阻塞</li></ul></li></ul></details></li></ul><ul id="0a6f45f2-964c-4a1c-bab1-c0c6841c4530" class="toggle"><li><details open=""><summary>一对一模型</summary><p id="8a852bd9-4abe-487a-badc-f46267686698" class="">一个用户线程映射到一个内核线程的模型，如<strong>Linux、Windows</strong></p><ul id="61e26938-da74-4bdb-9db4-0a60c7bcefba" class="bulleted-list"><li>优点：<ul id="d8643be8-6086-4d0d-b840-e7f2ab8c205f" class="bulleted-list"><li>可以提供<strong>并发</strong>功能，可以在多个处理器上并行执行</li></ul><ul id="49f6c706-fa1a-4a41-94da-35e3966daeb0" class="bulleted-list"><li>在一个线程执行阻塞系统调用时，可以调度另一个线程继续执行</li></ul></li></ul><ul id="779c340a-e9d5-423a-a9a7-dbcf053d508c" class="bulleted-list"><li>缺点：<p id="e1d84777-9f63-410b-9f79-642ad1bd0c94" class="">每次创建一个用户线程就需要创建一个内核线程，带来了额外的开销。</p></li></ul></details></li></ul><ul id="94b6f66b-97b4-4749-b1f7-fce73a9176e3" class="toggle"><li><details open=""><summary>多对一模型</summary><p id="71bd41ad-22a2-47e4-8afd-7f1725cee621" class="">多个用户线程映射一个内核线程，用户线程由用户空间管理，用于不支持<strong>内核线程</strong>的OS中</p><ul id="2777741a-e094-4628-a41f-36768c595181" class="bulleted-list"><li>缺点：<ul id="122d307c-9af9-4b6f-b917-feaf5276250c" class="bulleted-list"><li>任何时刻只能有一个线程可以访问内存，并发性低</li></ul><ul id="c56f19e6-617a-4129-ae27-c69d61790080" class="bulleted-list"><li>当一个用户线程阻塞，其他线程就被阻塞，并发能力差</li></ul></li></ul></details></li></ul><ul id="773ec99b-f144-4837-8154-d9df12383af9" class="toggle"><li><details open=""><summary>多对多模型</summary><ul id="15317323-b67b-4009-99d3-c08d67bff527" class="bulleted-list"><li>多个用户线程映射多个内核线程</li></ul><ul id="a2d24422-2e2e-415e-a874-f105912eb486" class="bulleted-list"><li>多对多模型没有以上模型的缺点，当一个线程执行阻塞系统调用时，内核可以调度另一个线程的执行，但是需要提供<strong>调度机制</strong>。<mark class="highlight-red">少量的内核线程为更多的用户线程服务，当内核线程数量不够的时候就会需要调度程序</mark></li></ul></details></li></ul><ul id="7d1f7a53-0b61-4c71-a17a-b24d8c4b4aa8" class="toggle"><li><details open=""><summary>混合模型（两级模型）</summary><p id="a92ea8ad-102c-44f9-afbe-3d71dbb881ec" class="">多对多模型的变种，允许用户绑定一个特定的内核线程</p></details></li></ul><p id="ad332512-c235-4f86-9480-662a9fa2359c" class="">
</p><h2 id="baabb0bd-439f-41aa-9dab-d3c539338171" class="">三、线程库</h2><ul id="25e0cb4c-57dc-4d89-9210-2c23f0c29b3a" class="toggle"><li><details open=""><summary>概述</summary><ol id="933faa71-fb27-48d7-aee2-cddcb270145a" class="numbered-list" start="1"><li>定义：
为程序员提供的创建和管理进程的API</li></ol><ol id="1e71255e-7026-4581-aced-9dc31e0747b0" class="numbered-list" start="2"><li>实现方式——2种：<ul id="97e9f253-0667-427c-b1d4-96a67fdf1a61" class="bulleted-list"><li>非嵌入到内核的方式：是在用户空间中提供一个<strong>没有内核支持</strong>的库,此库<strong>所有代码和数据结构都存在于用户空间</strong></li></ul><ul id="948cd7d3-d76b-4cd6-98b0-1d184231ec1d" class="bulleted-list"><li>嵌入到内核的方式：OS直接支持的内核库，此时所有<strong>代码和数据结构都存在于内核中</strong></li></ul><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="f6caa42e-44ba-4da8-a4e6-e5e9eaf775c7"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">用户空间中执行一些基本操作，比如加减运算，然后涉及系统调用的时候，会执行软中断，从用户态切换到内核态，执行命令。之后再切换回用户态。</div></figure></li></ol><ol id="65c545a4-34bb-498a-852d-27c1c5e52800" class="numbered-list" start="3"><li>实例：<p id="54946610-78e1-4611-82e8-dbb9848d830e" class="">目前主要三种线程库：</p><ul id="fa0cf271-0968-4107-9f44-dda7c6e848b1" class="bulleted-list"><li>posix pthread 用户级别和内核级别的库</li></ul><ul id="ccd13298-b7aa-498e-a307-31a442671696" class="bulleted-list"><li>win32 内核级嵌入到内核的方式</li></ul><ul id="dba75ac1-4096-480b-84fe-5c76d7db4ea2" class="bulleted-list"><li>Java Java线程API通常采用宿主系统上的线程库来实现</li></ul></li></ol></details></li></ul><ul id="81404f47-d0ce-4daf-b4c4-6b59aa0a8f08" class="toggle"><li><details open=""><summary>JVM和宿主操作系统</summary><p id="e391fb59-3586-4c50-8d02-ec798078b244" class="">定义：JVM一般在OS之上实现并且隐藏了基本的操作系统实现细节，从而提供了一种一致的、抽象的环境来允许Java程序在<strong>任何支持JVM的平台上运行</strong></p><ol id="faed7a56-fb1a-40e4-a00c-9cd67271b1c8" class="numbered-list" start="1"><li>JVM的规范没有指明JVM如何被映射到底层的OS，而让特定的<strong>JVM</strong>实现来决定</li></ol><ol id="d69c5318-21af-488d-b1f3-f1437060fd7e" class="numbered-list" start="2"><li>WIN XP是一对一模型，运行在该平台上的JVM就支持一对一模型，如Tru64 Unix是多对多模型，运行在该平台上的JVM就支持多对多模型<figure id="1686eef2-58be-44e4-a852-2b5c786cba06" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%204.png"><img style="width:284px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%204.png"/></a></figure></li></ol></details></li></ul><ul id="11dc231d-5470-496c-b9b0-2b1dd0e5a49f" class="toggle"><li><details open=""><summary>C语言线程示例</summary><ol id="4cde6fc3-ed4a-47a5-a9ca-8ad4b95e9fcc" class="numbered-list" start="1"><li>创建线程系统调用
如果线程创建成功就返回0，否则返回出错的编号<figure id="d43902c8-68dc-4091-b1ff-dde4d4114177" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%205.png"><img style="width:426px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%205.png"/></a></figure></li></ol><ol id="a0a7d2d1-c55b-42b6-b562-9864446e1617" class="numbered-list" start="2"><li>终止线程执行
<mark class="highlight-red">void pthread_exit()</mark></li></ol><ol id="2a46ea81-f8d2-4fe1-802d-0da7848d4f6d" class="numbered-list" start="3"><li>等待一个线程结束
成功就返回0，否则返回错误号
<mark class="highlight-red">int pthread_join(pthread_t thread, void **retval)
// thread ID and return value</mark></li></ol><ol id="9e1948a6-c8aa-4584-8b73-6480558645cc" class="numbered-list" start="4"><li>初始化线程对象
成功返回0，否则返回错误号
<mark class="highlight-red">int pthread_attr_init(pthread_attr_t *attr)</mark></li></ol><ol id="81e30dba-d967-4426-a1b8-c24ccff1e6be" class="numbered-list" start="5"><li>链接线程库
<mark class="highlight-red">gcc -o thread thread.c </mark><strong><mark class="highlight-red">-lpthread</mark></strong></li></ol></details></li></ul><p id="c983515e-c423-4411-947e-c60c8f24145d" class="">
</p><h2 id="c5d0bc1c-60da-4314-b04e-452ab38a6ce0" class="">四、多线程程序相关问题</h2><ul id="e054c70b-1747-455e-9f6c-713ff185e690" class="toggle"><li><details open=""><summary>系统调用fork()和系统调用exec()的语义：</summary><ol id="53cfedd2-3703-4fcc-9c1a-0fafcd0633c2" class="numbered-list" start="1"><li>若fork()的子进程与父进程做不同的工作，则需要调用exec()，此时<strong>只复制调用fork()的
那个线程</strong>（因为exec()要完全覆盖原线程，所以这样负担更小，更快）</li></ol><ol id="7d6121d3-6b7c-4eb9-bb54-7c9b3376dbeb" class="numbered-list" start="2"><li>若fork()的子进程与父进程做相同的工作，则不需调用exec()，此时需要复制<strong>全部线程</strong>。
（因为要复制原进程的所有内存空间，线程在内存中所以全都要复制）</li></ol></details></li></ul><figure id="18900b36-4a68-44b6-a531-58e29514b4ad" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%206.png"><img style="width:370px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%206.png"/></a></figure><ul id="67d36205-4f46-409e-9c9a-788b4cec9f97" class="toggle"><li><details open=""><summary>线程取消：</summary><ol id="ca1a059e-7a2f-41e9-8eb7-3bb39a2f9c13" class="numbered-list" start="1"><li>目标线程的定义：
线程完成任务之前终止线程的任务，需要取消的线程。</li></ol><ol id="0a316421-05e5-429b-a2a6-071049cb280e" class="numbered-list" start="2"><li>目标线程的取消方式（目标线程会共享其他线程的数据，所以需要取消）：<ul id="570d060b-30ff-415b-8604-73b6b824a4d1" class="bulleted-list"><li>异步取消（立即终止目标线程）</li></ul><ul id="24d7b3d5-d176-4112-a415-b77f3041b3cc" class="bulleted-list"><li>延迟取消（目标线程不断检查是否应该终止）</li></ul><p id="b7323e3a-dfbd-495c-a70b-4e32cfbdeb54" class=""><mark class="highlight-red">默认情况：延迟取消</mark></p></li></ol><ol id="87aec024-570c-4785-a30d-a3f310d0aee3" class="numbered-list" start="3"><li>目标线程的实现<p id="f129ff97-878b-4460-b50a-c4e4631b0951" class="">线程取消请求的实际取消的行为<strong>依赖于线程的状态</strong></p><ul id="996903ea-66f5-40ca-aa72-1a8e20b68a1e" class="bulleted-list"><li>Off Mode:
如果系统设置为禁用线程取消的话，线程取消会待定直到可以取消线程为止</li></ul><ul id="d0fc2233-cf27-42b3-b707-3feb62124757" class="bulleted-list"><li>Deffered Mode：
<mark class="highlight-red">默认状态</mark>，延迟取消</li></ul><ul id="e7276394-27fe-486f-95a9-f62223b6c728" class="bulleted-list"><li>Asynchronomous Mode：
异步模式，立即终止目标线程</li></ul></li></ol><ol id="29ad8bde-a545-4010-adbb-59664c48799c" class="numbered-list" start="4"><li>取消点：
当一个线程认定为可以安全取消时，可以安全取消的这个点称为取消点，即<strong>pthread_testcancel()</strong>会被调用。在Linux中，线程取消是通过信号来处理的</li></ol></details></li></ul><ul id="671512a7-a0e4-4c88-8fe6-4d83d841902c" class="toggle"><li><details open=""><summary>信号处理：</summary><p id="4683ec4f-1958-4343-9ff3-3f5330b6d0c0" class="">信号是用来通知<strong>进程</strong>某个特定事件的发生，这需要操作系统提供一种内核和进程之间的通信机制。</p><ol id="80398e26-43c0-4d88-8bc0-4a1b246c7daf" class="numbered-list" start="1"><li>分类<ul id="06336814-3b79-44d8-b102-99ff85dcf125" class="bulleted-list"><li>同步信号(内部信号)：进程本身事件产生的信号，如访问非法内存、除零等</li></ul><ul id="4c180386-baa7-4e7a-b0cc-774d87c7dc83" class="bulleted-list"><li>异步信号(外部信号)：进程之外事件产生的信号，如按CTRL+C键等</li></ul></li></ol><ol id="3f3b2568-e246-436e-860f-9e7819b094cd" class="numbered-list" start="2"><li>信号处理程序是用来处理发生的事件，处理过程如下：<ul id="be007ceb-5ea0-480e-b493-ba1a4c7617d0" class="bulleted-list"><li>步骤一: 由特定事件产生信号</li></ul><ul id="e50c5ecb-03de-4f83-ac48-6e1a7533256c" class="bulleted-list"><li>步骤二: 这个信号传送给进程</li></ul><ul id="d621daaf-0508-4123-bc18-0bd026cd9e50" class="bulleted-list"><li>步骤三: 信号处理程序处理相应信号
<strong>信号处理程序有</strong><mark class="highlight-teal"><strong>默认信号处理程序</strong></mark><strong>和</strong><mark class="highlight-teal"><strong>用户定义的信号处理程序</strong></mark></li></ul></li></ol><ol id="4bc15ca7-91a3-4593-8099-f39752b34a78" class="numbered-list" start="3"><li>需要考虑的问题：<ul id="124199a8-4fb5-4030-9eaa-222237810077" class="bulleted-list"><li>单线程进程，没有问题</li></ul><ul id="62206639-a074-46de-afc2-a0a68a765e77" class="bulleted-list"><li>多线程进程，应该传送给进程的哪个线程<ul id="26abc7b1-ae89-4d83-bbc2-ccada9ba34a7" class="bulleted-list"><li>发送信号到信号所应用的线程</li></ul><ul id="22cd93f2-4ba1-488e-be82-aed804a08f46" class="bulleted-list"><li>发送信号到进程内每个线程</li></ul><ul id="b37d0eeb-cb23-419c-8b11-3903abb5d1c3" class="bulleted-list"><li>发送信号到进程某个固定线程</li></ul><ul id="d7d6e7e9-2d24-494e-8200-eebf79521331" class="bulleted-list"><li>规定一个特定的线程一接收进程的所有信号</li></ul></li></ul><p id="95a3a266-63af-4664-ac25-6c1f8142e335" class="block-color-blue">发送信号的方法依赖于产生信号的类型</p><ul id="09299db9-7e1a-4b63-b5ca-ee9d309f8181" class="bulleted-list"><li>CTRL+C产生的信号必须发送给进程的<mark class="highlight-red">每一个线程</mark></li></ul><ul id="92491d9f-9633-4427-8ba8-4bd5d4a0f990" class="bulleted-list"><li>Pthread提供的pthread_kill(pthread_t tid, int signal)函数就可以把信号传送给<mark class="highlight-red">指定的线程</mark></li></ul></li></ol></details></li></ul><ul id="ecb0930f-1eae-4f4f-9a50-a094a012c859" class="toggle"><li><details open=""><summary>线程池：</summary><ol id="15e0bbef-b035-4ebf-bf08-0b1d70014433" class="numbered-list" start="1"><li>定义：线程池（thread pool）的主要思想是在进程开始时创建一定数量的线程，并放入到线程池中<mark class="highlight-red">等待工作</mark></li></ol><ol id="15de6d02-512e-423c-be79-14d1da80266c" class="numbered-list" start="2"><li>优点：</li></ol><ul id="c32b7906-674b-4222-91d9-3203e871b46f" class="bulleted-list"><li>通常用现有线程处理请求要比等待创建新的线程要快</li></ul><ul id="6944c0e7-9048-432b-b5b8-21a13023f13c" class="bulleted-list"><li>线程池限制了在任何时候可用线程的数量，这可以防止大量创建并发线程，有助于管理</li></ul><figure id="2796f21c-6092-4b43-a0a4-0c651c719431" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%207.png"><img style="width:723px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%207.png"/></a></figure></details></li></ul><ul id="d7e12aef-e15f-4cf0-bb07-bf1bff5fd1b9" class="toggle"><li><details open=""><summary>调度程序激活：</summary><ol id="a6dae6f9-5cfc-4627-876e-b4eede07591b" class="numbered-list" start="1"><li>引入<p id="fd657393-bfdd-4113-af98-8760a456e623" class="">多对多模型和二层模型中的用户线程和内核线程需要通信，以便<mark class="highlight-red">维持内核线程的适当数量</mark></p><ul id="22b7480f-4ede-456b-bf89-e88ac89e59a8" class="bulleted-list"><li>用户和内核线程之间设置一种中间数据结构，这种数据结构通常称为<mark class="highlight-yellow">轻量级进程</mark>（LWP：Light Weight Process）</li></ul><ul id="eba78e39-e4ba-44d1-b1f5-921eca8fd37c" class="bulleted-list"><li>对于用户线程库，LWP表现为一种应用程序可以调度用户线程的虚拟处理器</li></ul><ul id="0bd008c8-29ac-46f9-82c5-5b9804f5cc5b" class="bulleted-list"><li>每个LWP与内核线程相连，该内核线程被操作系统调度到物理处理器上运行</li></ul><ul id="d400e048-e062-4701-ba30-044cedfa70e1" class="bulleted-list"><li>如果内核线程阻塞，LWP也阻塞，相连用户线程也会阻塞<figure id="728c5ac7-0104-4db9-8b0f-742af85d905a" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%208.png"><img style="width:251px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%208.png"/></a></figure></li></ul></li></ol><ol id="f1f9eea9-bbca-473c-8cfe-8dd30b3e3062" class="numbered-list" start="2"><li>定义：
调度程序激活是一种解决用户线程库和内核之间通信的方法<ul id="09390305-9476-4ffa-9d71-1a478975f7a7" class="bulleted-list"><li>内核提供一组LWP给应用程序，应用程序可调度用户线程到一个可用的LWP上</li></ul><ul id="64d730b7-c41c-48e0-860c-de103ddd1b06" class="bulleted-list"><li><mark class="highlight-yellow">调度程序激活</mark>提供内核和线程库之间的通信机制，这个通信机制称为<mark class="highlight-yellow">UPCALL</mark></li></ul><ul id="c6a10da5-3845-498b-9578-2c3d67b88344" class="bulleted-list"><li>UPCALL由具有UPCALL处理句柄的线程库处理，而且UPCALL处理句柄必须在<mark class="highlight-red">虚拟处理器上</mark>运行</li></ul><ul id="bc3eb4c9-cfc1-430f-8ccd-f50b5fce32e8" class="bulleted-list"><li>这种通信机制允许应用程序保持适当的内核线程数量</li></ul></li></ol><ol id="22bfecc9-a3e6-478a-b5df-be13be8c7f2c" class="numbered-list" start="3"><li>实例：</li></ol><figure id="f45a94f2-be2a-43f3-9661-5a2cba74695b" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%209.png"><img style="width:724px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%209.png"/></a></figure><figure id="3e8c0e26-9194-437e-8141-6cdfd480114f" class="image"><a href="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%2010.png"><img style="width:737px" src="%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%20%E7%BA%BF%E7%A8%8B%205d1bc8818e3d4fdeacb772ffcbe44843/Untitled%2010.png"/></a></figure><ul id="c59c8670-32df-4b91-ad5a-ca206c6ad640" class="bulleted-list"><li>当用户线程1被阻塞的时候，内核使用upcall通信机制告知应用线程阻塞</li></ul><ul id="28081b00-0589-467e-91f6-8934679cdce1" class="bulleted-list"><li>当用户进程4需要和内核映射的时候，upcall通信机制应当安排一个新的LWP</li></ul><ul id="6642b7b1-a71b-45f1-9011-1f61b6e50e8d" class="block-color-red bulleted-list"><li>upcall通信机制：<strong>识别阻塞的线程、保存阻塞线程的状态、给一个新的线程分配可用的LWP</strong></li></ul></details></li></ul><p id="f7dfc908-8270-4cdf-ac41-1f5bb655282d" class="">
</p></div></article></body></html>